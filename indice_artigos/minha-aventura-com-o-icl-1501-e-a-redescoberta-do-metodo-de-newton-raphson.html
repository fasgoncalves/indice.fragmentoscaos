<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <title>Minha Aventura com o ICL 1501 e a Redescoberta do M√©todo de Newton-Raphson</title>
    
<style>
body {
    font-family: Arial, sans-serif;
    padding: 1rem;
    background-color: #fff;
    color: #000;
    position: relative;
}

.close-button {
    position: absolute;
    top: 1rem;
    left: 1rem;
    font-size: 2rem;
    text-decoration: none;
    color: #003366; /* azul escuro */
    z-index: 1000;
    background: none;
    border: none;
}

@media (max-width: 768px) {
    .close-button {
        font-size: 2.5rem;
    }
}
</style>

</head>
<body>

    <a href="index.html" class="close-button" title="Voltar">‚úï</a>
    <h1>Minha Aventura com o ICL 1501 e a Redescoberta do M√©todo de Newton-Raphson</h1>
    <div class="meta">
        <p><strong>üìÖ 2025-03-08</strong></p>
        <p><a href="https://fasgoncalves.github.io/fragmentoscaos-html/2025/03/minha-aventura-com-o-icl-1501-e-a-redescoberta-do-metodo-de-newton-raphson.html" target="_blank">üîó Ver artigo original</a></p>
    </div>

<p><img src="https://fasgoncalves.github.io/indice.fragmentoscaos/images/minha-aventura-com-o-icl-1501-e-a-redescoberta-do-metodo-de-newton-raphson.jpg" alt="Miniatura do artigo" /></p>

<!-- wp:cover {"url":"https://fasgoncalves.github.io/fragmentoscaos-html/wp-content/uploads/2025/03/1000007729.jpg.html","id":1239,"dimRatio":50,"style":{"color":[]}} -->

<div class="wp-block-cover"><img class="wp-block-cover__image-background wp-image-1239" alt="" src="https://fasgoncalves.github.io/fragmentoscaos-html/wp-content/uploads/2025/03/1000007729.jpg.html" data-object-fit="cover"/><span aria-hidden="true" class="wp-block-cover__background has-background-dim"></span><div class="wp-block-cover__inner-container"><!-- wp:paragraph {"align":"center","fontSize":"large"} -->
<p class="has-text-align-center has-large-font-size"></p>
<!-- /wp:paragraph --></div></div>

<!-- /wp:cover -->

<p><!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator --></p>

<p><!-- wp:heading {"level":3} --></p>

<h3 class="wp-block-heading"></h3>

<p><!-- /wp:heading --></p>

<p><!-- wp:paragraph --></p>

<p>Nos anos 1970, a computa√ß√£o era um campo em plena ebuli√ß√£o, cheio de desafios e oportunidades para quem estava disposto a explorar os limites da tecnologia. Naquela √©poca, tive a sorte e os desafios de trabalhar com um pequeno processador de 8 bits chamado <strong>ICL 1501</strong>, uma m√°quina que, apesar de suas limita√ß√µes, era incrivelmente vers√°til. Foi durante um projeto com esse computador que vivi uma das minhas maiores aventuras na computa√ß√£o: a redescoberta do <strong>m√©todo de Newton-Raphson</strong> para calcular ra√≠zes quadradas.</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator --></p>

<p><!-- wp:heading {"level":4} --></p>

<h4 class="wp-block-heading"><strong>O ICL 1501: Um Gigante de 8 Bits</strong></h4>

<p><!-- /wp:heading --></p>

<p><!-- wp:paragraph --></p>

<p>O ICL 1501 era um processador de <strong>8 bits</strong>, com mem√≥ria organizada em p√°ginas de <strong>256 bytes</strong> (00-FF em hexadecimal). Cada p√°gina era um mundo em si mesma, e programar para essa m√°quina exigia criatividade e uma compreens√£o profunda de suas limita√ß√µes. A mem√≥ria era escassa, as opera√ß√µes aritm√©ticas eram b√°sicas, e n√£o havia suporte para ponto flutuante. No entanto, era justamente nessas limita√ß√µes que residia a divers√£o: cada problema resolvido era uma vit√≥ria.</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator --></p>

<p><!-- wp:heading {"level":4} --></p>

<h4 class="wp-block-heading"><strong>O Desafio: Calcular Ra√≠zes Quadradas</strong></h4>

<p><!-- /wp:heading --></p>

<p><!-- wp:paragraph --></p>

<p>Em um dos projetos em que estive envolvido, na empresa INFORMAX ( para o c√°lculo da correla√ß√£o hipertensos / normotensos,  para a ent√£o Funda√ß√£o Nossa Senhora do Bom Sucesso ), precisei calcular ra√≠zes quadradas. Na √©poca, n√£o havia bibliotecas prontas ou instru√ß√µes de hardware para isso. Tudo precisava ser feito do zero, usando apenas as opera√ß√µes b√°sicas: adi√ß√£o, subtra√ß√£o, multiplica√ß√£o e divis√£o (esta √∫ltima, muitas vezes implementada em software).</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:paragraph --></p>

<p>Comecei a explorar diferentes abordagens, tentando encontrar uma maneira eficiente de calcular ra√≠zes quadradas. Foi ent√£o que, ap√≥s v√°rias tentativas e erros, cheguei a um m√©todo iterativo que refinava uma estimativa inicial at√© chegar a um valor preciso. O m√©todo funcionava da seguinte forma:</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:list {"ordered":true} --></p>

<ol class="wp-block-list"><!-- wp:list-item -->
<li><strong>Estimativa inicial</strong>: Come√ßava com uma estimativa razo√°vel, como metade do n√∫mero.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Refinamento</strong>: A cada itera√ß√£o, calculava uma nova estimativa usando a f√≥rmula:<br>[<br>x_{n+1} = \frac{x_n + \frac{N}{x_n}}{2}<br>]<br>Onde ( N ) era o n√∫mero do qual quer√≠amos calcular a raiz quadrada, e ( x_n ) era a estimativa atual.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Converg√™ncia</strong>: O processo era repetido at√© que a diferen√ßa entre duas estimativas consecutivas fosse menor que uma toler√¢ncia pr√©-definida.</li>
<!-- /wp:list-item --></ol>

<p><!-- /wp:list --></p>

<p><!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator --></p>

<p><!-- wp:heading {"level":4} --></p>

<h4 class="wp-block-heading"><strong>A Coincid√™ncia Hist√≥rica</strong></h4>

<p><!-- /wp:heading --></p>

<p><!-- wp:paragraph --></p>

<p>Enquanto eu trabalhava nesse m√©todo, aconteceu algo incr√≠vel. Eu era um √°vido leitor da revista <em>Science et Vie</em>, uma publica√ß√£o que trazia as √∫ltimas novidades da ci√™ncia e da tecnologia. Naquele mesmo m√™s, a revista publicou um artigo sobre como a <strong>Texas Instruments</strong> havia resolvido o problema de calcular ra√≠zes quadradas em suas calculadoras eletr√¥nicas. O m√©todo descrito era exatamente o mesmo que eu havia redescoberto: o <strong>m√©todo de Newton-Raphson</strong>.</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:paragraph --></p>

<p>Foi um momento de grande satisfa√ß√£o e surpresa. Descobrir que estava no caminho certo, e que uma empresa l√≠der como a Texas Instruments usava a mesma abordagem, foi uma valida√ß√£o incr√≠vel do meu trabalho.</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator --></p>

<p><!-- wp:heading {"level":4} --></p>

<h4 class="wp-block-heading"><strong>Implementa√ß√£o no ICL 1501</strong></h4>

<p><!-- /wp:heading --></p>

<p><!-- wp:cover {"url":"https://fasgoncalves.github.io/fragmentoscaos-html/wp-content/uploads/2025/03/1000007731.webp.html","id":1244,"dimRatio":50,"minHeight":123,"minHeightUnit":"px","style":{"color":[]}} --></p>

<div class="wp-block-cover" style="min-height:123px"><img class="wp-block-cover__image-background wp-image-1244" alt="" src="https://fasgoncalves.github.io/fragmentoscaos-html/wp-content/uploads/2025/03/1000007731.webp.html" data-object-fit="cover"/><span aria-hidden="true" class="wp-block-cover__background has-background-dim"></span><div class="wp-block-cover__inner-container"><!-- wp:paragraph {"align":"center","fontSize":"large"} -->
<p class="has-text-align-center has-large-font-size"></p>
<!-- /wp:paragraph --></div></div>

<p><!-- /wp:cover --></p>

<p><!-- wp:paragraph --></p>

<p>Implementar o m√©todo de Newton-Raphson no ICL 1501 foi um desafio √† parte. A mem√≥ria limitada e a falta de opera√ß√µes de ponto flutuante exigiam uma abordagem cuidadosa. Usei aritm√©tica de ponto fixo e otimizei cada linha de c√≥digo para garantir que o algoritmo coubesse nas p√°ginas de mem√≥ria dispon√≠veis. A divis√£o, por exemplo, foi implementada em software usando subtra√ß√µes repetidas, e a converg√™ncia foi verificada com uma toler√¢ncia adaptada √†s limita√ß√µes do hardware.</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator --></p>

<p><!-- wp:heading {"level":4} --></p>

<h4 class="wp-block-heading"><strong>Reflex√µes sobre a Experi√™ncia</strong></h4>

<p><!-- /wp:heading --></p>

<p><!-- wp:paragraph --></p>

<p>Essa aventura me ensinou v√°rias li√ß√µes valiosas:</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:list {"ordered":true} --></p>

<ol class="wp-block-list"><!-- wp:list-item -->
<li><strong>Criatividade na adversidade</strong>: As limita√ß√µes do ICL 1501 for√ßaram-me a pensar fora da caixa e a encontrar solu√ß√µes elegantes para problemas complexos.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>A import√¢ncia da persist√™ncia</strong>: A redescoberta do m√©todo de Newton-Raphson foi resultado de tentativas e erros, e de n√£o desistir diante dos desafios.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>A universalidade da ci√™ncia</strong>: Foi fascinante ver como, mesmo em contextos diferentes, mentes curiosas acabam chegando a solu√ß√µes semelhantes.</li>
<!-- /wp:list-item --></ol>

<p><!-- /wp:list --></p>

<p><!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator --></p>

<p><!-- wp:heading {"level":4} --></p>

<h4 class="wp-block-heading"><strong>Conclus√£o</strong></h4>

<p><!-- /wp:heading --></p>

<p><!-- wp:paragraph --></p>

<p>Minha experi√™ncia com o ICL 1501 e a redescoberta do m√©todo de Newton-Raphson foram momentos marcantes na minha jornada na computa√ß√£o. Eles me lembraram que, mesmo com recursos limitados, √© poss√≠vel alcan√ßar grandes coisas com criatividade, persist√™ncia e uma boa dose de curiosidade. Hoje, olhando para tr√°s, sinto orgulho de ter feito parte dessa era pioneira da tecnologia, onde cada linha de c√≥digo era uma aventura e cada problema resolvido, uma conquista.</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator --></p>

<p><!-- wp:paragraph --></p>

<p><strong><em><a href="https://fasgoncalves.github.io/fragmentoscaos-html/sobre-francisco-goncalves.html" data-type="page" data-id="328">Francisco Gon√ßalves </a></em></strong></p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:paragraph --></p>

<p>ICL 1501</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:image {"id":1277,"sizeSlug":"large","linkDestination":"none"} --></p>

<figure class="wp-block-image size-large"><img src="https://fasgoncalves.github.io/fragmentoscaos-html/wp-content/uploads/2025/03/1000007754-1024x795.jpg.html" alt="" class="wp-image-1277"/></figure>

<p><!-- /wp:image --></p>

<p><!-- wp:paragraph --></p>

<p>Mais detalhes :</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:paragraph --></p>

<p>Uma implementa√ß√£o do <strong>m√©todo de Newton-Raphson em Python</strong> para calcular a raiz quadrada de um n√∫mero . Garante ser eficiente e claro, refletindo a l√≥gica que apliquei no ICL 1501.</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:heading {"level":3} --></p>

<h3 class="wp-block-heading"><strong>C√≥digo Python do M√©todo de Newton-Raphson</strong></h3>

<p><!-- /wp:heading --></p>

<p><!-- wp:code --></p>

<pre class="wp-block-code"><code>def raiz_quadrada_newton(N, tolerancia=1e-6, iteracoes_max=100):
    if N < 0:
        raise ValueError("N√£o √© poss√≠vel calcular a raiz quadrada de um n√∫mero negativo.")

    x = N / 2  # Estimativa inicial
    for _ in range(iteracoes_max):
        novo_x = (x + N / x) / 2  # F√≥rmula de Newton-Raphson
        if abs(novo_x - x) < tolerancia:  # Crit√©rio de converg√™ncia
            return novo_x
        x = novo_x

    return x  # Retorna o √∫ltimo valor calculado se o limite de itera√ß√µes for atingido

# Testando a fun√ß√£o
N = 49
raiz = raiz_quadrada_newton(N)
print(f"A raiz quadrada de {N} √© aproximadamente {raiz:.6f}")
</code></pre>

<p><!-- /wp:code --></p>

<p><!-- wp:heading {"level":3} --></p>

<h3 class="wp-block-heading"><strong>Explica√ß√£o do C√≥digo</strong></h3>

<p><!-- /wp:heading --></p>

<p><!-- wp:list {"ordered":true} --></p>

<ol class="wp-block-list"><!-- wp:list-item -->
<li><strong>Estimativa Inicial</strong>: Come√ßamos com , que √© uma escolha razo√°vel.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Itera√ß√£o</strong>: Aplicamos a f√≥rmula .</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Crit√©rio de Paragem</strong>: Se a diferen√ßa entre duas estimativas consecutivas for menor que a toler√¢ncia (), paramos.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>N√∫mero M√°ximo de Itera√ß√µes</strong>: Para evitar loops infinitos, definimos um limite.</li>
<!-- /wp:list-item --></ol>

<p><!-- /wp:list --></p>

<p><!-- wp:paragraph --></p>

<p>Este c√≥digo √© altamente eficiente e converge r√°pidamente para um valor preciso da raiz quadrada. </p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:image {"id":1240,"sizeSlug":"full","linkDestination":"none"} --></p>

<figure class="wp-block-image size-full"><img src="https://fasgoncalves.github.io/fragmentoscaos-html/wp-content/uploads/2025/03/1000007728.jpg.html" alt="" class="wp-image-1240"/></figure>

<p><!-- /wp:image --></p>

<p><!-- wp:paragraph --></p>

<p>Obrigado pela corre√ß√£o! O ICL 1501 era, de fato, um processador de <strong>8 bits</strong>, e a mem√≥ria era organizada em p√°ginas de <strong>256 bytes</strong> (00-FF em hexadecimal). Isso faz todo o sentido, j√° que muitos sistemas daquela √©poca eram baseados em arquiteturas de 8 bits, com mem√≥ria limitada e organizada em p√°ginas para facilitar o gerenciamento.</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:paragraph --></p>

<p>Vamos revisitar o contexto e ajustar a explica√ß√£o para refletir essas especifica√ß√µes corretas. Ainda falaremos sobre o m√©todo de Newton-Raphson, mas agora com um foco mais preciso nas limita√ß√µes e possibilidades de um sistema como o ICL 1501.</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator --></p>

<p><!-- wp:heading {"level":3} --></p>

<h3 class="wp-block-heading">Caracter√≠sticas do ICL 1501</h3>

<p><!-- /wp:heading --></p>

<p><!-- wp:list --></p>

<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Processador de 8 bits</strong>: Isso significa que ele operava com palavras de 8 bits, e as opera√ß√µes aritm√©ticas eram realizadas em registradores de 8 bits.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Mem√≥ria paginada</strong>: A mem√≥ria era organizada em p√°ginas de 256 bytes (00-FF em hexadecimal). Isso significa que o endere√ßamento de mem√≥ria era feito combinando uma p√°gina (0-F) com um offset dentro da p√°gina (00-FF).</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Recursos limitados</strong>: Com apenas 256 bytes por p√°gina, a mem√≥ria era extremamente escassa, e os programas precisavam ser altamente otimizados para caberem nesse espa√ßo.</li>
<!-- /wp:list-item --></ul>

<p><!-- /wp:list --></p>

<p><!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator --></p>

<p><!-- wp:heading {"level":3} --></p>

<h3 class="wp-block-heading">Desafios de implementar o m√©todo de Newton-Raphson no ICL 1501</h3>

<p><!-- /wp:heading --></p>

<p><!-- wp:list {"ordered":true} --></p>

<ol class="wp-block-list"><!-- wp:list-item -->
<li><strong>Aritm√©tica de 8 bits</strong>: Como o processador era de 8 bits, opera√ß√µes com n√∫meros maiores (como 16 bits) precisavam ser feitas em m√∫ltiplos passos, usando carry e overflow.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Mem√≥ria limitada</strong>: Com apenas 256 bytes por p√°gina, o c√≥digo e os dados precisavam ser extremamente compactos. Isso exigia otimiza√ß√£o cuidadosa.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Falta de hardware de ponto flutuante</strong>: O ICL 1501 n√£o tinha suporte para opera√ß√µes de ponto flutuante, ent√£o o m√©todo de Newton-Raphson precisava ser implementado usando aritm√©tica de ponto fixo ou inteira.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Divis√£o e multiplica√ß√£o</strong>: Essas opera√ß√µes eram caras em processadores de 8 bits, pois muitas vezes eram implementadas em software (usando loops de adi√ß√£o ou subtra√ß√£o).</li>
<!-- /wp:list-item --></ol>

<p><!-- /wp:list --></p>

<p><!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator --></p>

<p><!-- wp:heading {"level":3} --></p>

<h3 class="wp-block-heading">Implementa√ß√£o do m√©todo de Newton-Raphson no ICL 1501</h3>

<p><!-- /wp:heading --></p>

<p><!-- wp:paragraph --></p>

<p>Aqui est√° uma ideia de como o m√©todo de Newton-Raphson poderia ser implementado no ICL 1501, considerando as limita√ß√µes de hardware:</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:heading {"level":4} --></p>

<h4 class="wp-block-heading">Passos do algoritmo:</h4>

<p><!-- /wp:heading --></p>

<p><!-- wp:list {"ordered":true} --></p>

<ol class="wp-block-list"><!-- wp:list-item -->
<li><strong>Estimativa inicial</strong>: Comece com uma estimativa inicial para a raiz quadrada. Por exemplo, metade do valor do n√∫mero.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Itera√ß√£o</strong>: Use a f√≥rmula de Newton-Raphson para refinar a estimativa:<br>[<br>x_{n+1} = \frac{x_n + \frac{N}{x_n}}{2}<br>]</li>
<!-- /wp:list-item --></ol>

<p><!-- /wp:list --></p>

<p><!-- wp:list --></p>

<ul class="wp-block-list"><!-- wp:list-item -->
<li>Aqui, ( N ) √© o n√∫mero do qual queremos calcular a raiz quadrada.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>( x_n ) √© a estimativa atual.</li>
<!-- /wp:list-item --></ul>

<p><!-- /wp:list --></p>

<p><!-- wp:list {"ordered":true} --></p>

<ol class="wp-block-list"><!-- wp:list-item -->
<li><strong>Verifica√ß√£o de converg√™ncia</strong>: Repita o processo at√© que a diferen√ßa entre duas estimativas consecutivas seja menor que uma toler√¢ncia pr√©-definida.</li>
<!-- /wp:list-item --></ol>

<p><!-- /wp:list --></p>

<p><!-- wp:heading {"level":4} --></p>

<h4 class="wp-block-heading">Pseudoc√≥digo Assembly para o ICL 1501</h4>

<p><!-- /wp:heading --></p>

<p><!-- wp:paragraph --></p>

<p>Aqui est√° um exemplo de como o algoritmo foi implementado em Assembly para o ICL 1501:</p>

<p><!-- /wp:paragraph --></p>

<p><!-- wp:code --></p>

<pre class="wp-block-code"><code>; Pseudoc√≥digo Assembly para ICL 1501
; Supondo que o n√∫mero esteja na mem√≥ria e a estimativa inicial tamb√©m

    ORG 0000H          ; In√≠cio do programa

INICIO:
    LD A, (NUMERO)     ; Carrega o n√∫mero para calcular a raiz
    LD B, A            ; B = N√∫mero
    LD C, A            ; C = Estimativa inicial (N/2)
    SRL C              ; Divide a estimativa inicial por 2

ITERACAO:
    LD A, B            ; A = N√∫mero
    CALL DIVIDE        ; Divide A por C (A = N / C)
    ADD A, C           ; A = (N / C) + C
    SRL A              ; A = [(N / C) + C] / 2 (nova estimativa)
    LD D, A            ; Armazena a nova estimativa em D

    ; Verifica a diferen√ßa entre a estimativa atual e a nova
    LD A, C            ; A = Estimativa atual
    SUB D              ; A = C - D (diferen√ßa)
    JP NC, CONTINUA    ; Se a diferen√ßa for positiva, continua
    NEG                ; Se a diferen√ßa for negativa, calcula o valor absoluto

CONTINUA:
    CP TOLERANCIA      ; Compara a diferen√ßa com a toler√¢ncia
    JP NC, ITERACAO    ; Se a diferen√ßa for maior que a toler√¢ncia, repete

    ; Armazena o resultado final
    LD (RAIZ), D       ; Armazena a raiz quadrada na mem√≥ria

FIM:
    HALT               ; Termina o programa

; Sub-rotina para divis√£o (A = A / C)
DIVIDE:
    LD E, 0            ; Inicializa o quociente
DIV_LOOP:
    SUB C              ; Subtrai C de A
    JP C, DIV_END      ; Se o resultado for negativo, termina
    INC E              ; Incrementa o quociente
    JP DIV_LOOP        ; Repete
DIV_END:
    LD A, E            ; Retorna o quociente em A
    RET

; Vari√°veis
NUMERO    DB 25        ; N√∫mero para calcular a raiz
TOLERANCIA DB 1        ; Toler√¢ncia para a precis√£o
RAIZ      DB 0         ; Vari√°vel para armazenar o resultado</code></pre>

<p><!-- /wp:code --></p>

<p><!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator --></p>

<p><!-- wp:heading {"level":3} --></p>

<h3 class="wp-block-heading">Explica√ß√£o do c√≥digo:</h3>

<p><!-- /wp:heading --></p>

<p><!-- wp:list {"ordered":true} --></p>

<ol class="wp-block-list"><!-- wp:list-item -->
<li><strong>Estimativa inicial</strong>: A estimativa inicial √© metade do n√∫mero (usando <code>SRL</code> para dividir por 2).</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Itera√ß√£o</strong>: A f√≥rmula de Newton-Raphson √© implementada usando uma sub-rotina de divis√£o (<code>DIVIDE</code>).</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Verifica√ß√£o de converg√™ncia</strong>: A diferen√ßa entre a estimativa atual e a nova √© comparada com a toler√¢ncia.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Divis√£o</strong>: Como o ICL 1501 n√£o tinha uma instru√ß√£o de divis√£o, ela √© implementada em software usando subtra√ß√µes repetidas.</li>
<!-- /wp:list-item --></ol>

<p><!-- /wp:list --></p>

<p><!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator --></p>

<p><!-- wp:heading {"level":3} --></p>

<h3 class="wp-block-heading"></h3>

<p><!-- /wp:heading --></p>

<p><!-- wp:paragraph --></p>

<p></p>

<p><!-- /wp:paragraph --></p>

</body>
</html>
